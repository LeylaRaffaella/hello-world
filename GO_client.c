/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "GO.h"
#include <stdio.h>
#include <time.h>
#include <stdlib.h>
void
go_oram_32(char *host)
{
	CLIENT *clnt;
	rx  *result_1;
	values  read_32_arg;
	rx  *result_2;
	values  write_32_arg;

read_32_arg.N=10;
read_32_arg.s=6;

printf ("The Arrey lenght is :%d\n",read_32_arg.N);
printf ("The shelter lenght is :%d\n",read_32_arg.s);


int B[read_32_arg.N];
B[0]=100;
B[1]=90;
B[2]=80;
B[3]=70;
B[4]=60;
B[5]=50;
B[6]=40;
B[7]=30;
B[8]=20;
B[9]=10;

int i;
struct VPM {         ///    PM[i]  =  (M,pi(i))
   
char lev;
int pos;
 
};

struct VPM *VPmap=malloc ( sizeof(struct VPM)*read_32_arg.N ) ;//struct  P_M   positionmap[N]

int array[read_32_arg.N];
int dommyarray[read_32_arg.s];
int BNS[read_32_arg.N];  
memset (BNS,0,sizeof BNS);////////// ba memset sefr mirizim baraye arayehayi ke toole motaghayer darand

srand(time(0));

printf ("The Array B is :\n");
for (i=0;i<read_32_arg.N;i++)
printf ("%d......%d\n",i,B[i]);


printf ("array[i] is :\n");
for (int i = 0; i < read_32_arg.N; i++) {     // fill array
    array[i] = i;
    printf("%d  ", array[i]);
}
printf("\n done with population \n");
printf("here is the final array\n");

for (int i = 0; i < read_32_arg.N; i++) {    // shuffle array
    int temp = array[i];
    int prn = rand() % (read_32_arg.N);


    array[i]   = array[prn]; 
    array[prn] = temp;     
}

printf("\n");
for (int i = 0; i < read_32_arg.N; i++) {    // print array
    printf("%d..............%d\n",i,array[i]);
    VPmap[i].pos=array[i] ;
    VPmap[i].lev='M';////
}


for (int i = 0; i < read_32_arg.N; i++) {
   BNS[array[i]]=B[i]; 
   
  } 


printf ("BNS[i] is :\n");
for (int i = 0; i < read_32_arg.N; i++) 
 printf ("%d\n",BNS[i]);  



printf (" BNS[i] is :\n");
for (i=0;i<read_32_arg.N;i++){           
    printf ("%d....%d\n",array[i],BNS[array[i]]);   }

printf ("after randomization Array[i] , BNS[array[i]] are :\n");
for (i=0;i<read_32_arg.N; i++) 
printf ("%d...............%d\n",array[i],BNS[array[i]]);


for (i=0;i<read_32_arg.N;i++) ////// ****** edame inja dommy hara mirize az N ta s
read_32_arg.a[i]=BNS[i];

printf ("THis is read _32_arg.a[0...N] :\n");

for (i=0;i<read_32_arg.N;i++)
printf ("%d\n",read_32_arg.a[i]);
//////////////////////////    dommy permutations

int DBS[read_32_arg.s];
srand(time(0));
printf ("before Random Permutation per i dommy blocks :\n");
for (i = read_32_arg.N; i < read_32_arg.N+read_32_arg.s; i++) {     // fill array
    dommyarray[i] = i;
    printf("%d   ", dommyarray[i]);
}
printf("\n done with population \n");
printf("here is the final array\n");

for ( i = read_32_arg.N; i < read_32_arg.N+read_32_arg.s; i++) {    // shuffle array
    int t= dommyarray[i];
    int max= read_32_arg.N+read_32_arg.s;
    int min=read_32_arg.N;
    int r=rand();
    printf ("rand() is :%d\n",r);
    int pr=(r % (max-min))+min;

    dommyarray[i]   = dommyarray[pr]; 
    dommyarray[pr] = t;
  }

for ( i = read_32_arg.N; i < read_32_arg.N+read_32_arg.s; i++) {    // print array
    printf("%d....%d\n",i,dommyarray[i]); 
    dommyarray[i]=dommyarray[i]*100;
  }
printf("\n");
printf ("Randm Permutation for dommy blocks is :\n");

/*for ( i = read_32_arg.N; i < read_32_arg.N+read_32_arg.s; i++) {  // print array,doroste, ehtiaj nist
    //printf("%d\n",dommyarray[i]);

}*/

for ( i = read_32_arg.N; i < read_32_arg.N+read_32_arg.s; i++) {    // print array
    printf("%d.........%d\n",i,dommyarray[i]);

}
for (i = read_32_arg.N; i < read_32_arg.N+read_32_arg.s; i++) {//// ***dommy hara mirize az N ta s
  
  DBS[i]=dommyarray[i];   
  read_32_arg.a[i]=DBS[i]; 
   
  }  ///

printf ("THis is read _32_arg.a[N...s] :\n");
for (i = read_32_arg.N; i < read_32_arg.N+read_32_arg.s; i++)
printf(" %d \n",read_32_arg.a[i]);

printf ("This is read_32_arg.a[i]\n");
for (i = 0; i < read_32_arg.N+read_32_arg.s; i++)
printf ("%d   \n",read_32_arg.a[i]);

////////////////////////////////////////

int *Sh;
Sh=(int*) malloc (sizeof(read_32_arg.s));

printf ("********* sizeof *Shelter is :%ld\n",sizeof(Sh));

int dCnt =read_32_arg.N;  // dummy block e query nashdeye badi ra
int nSh=0 ; // makane khali e badi dar Sh ra
    
             ////////////////////////////

#ifndef	DEBUG
	clnt = clnt_create (host, GO_ORAM, ver, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */


	result_1 = read_32(&read_32_arg, clnt);
	if (result_1 == (rx *) NULL) {
		clnt_perror (clnt, "call failed");
	}
//clnt_destroy (clnt);##### destroy nemikonim ta baz bemanad chon badan irad migirad
    /////////////////////////////////////////////////////////////


printf (" here is VPmap[i].lev  ,  VPmap[i].pos \n");
for (int i = 0; i < read_32_arg.N; i++)     
printf("%d.........%d\n" ,VPmap[i].lev,VPmap[i].pos);
   
    //////////////////////////////////////////////////

  /* for(i=0;i<read_27_arg.N;i++)  ****** MOhem : inja nabayad bashe ,payin     bashe *********   
  read_32_arg.N=10;
  read_32_arg.s=6;
  read_32_arg.q=qu-1; */
int t=0;

printf ("Start the query :\n");
int qu;
int nq=0;

do{
                   
           printf ("which block do you want to access ?\n");
           scanf ("%d",&qu); nq++ ;  //arrq[t]=qu; t++ ;
           printf ("nq is :%d\n",nq); 

     //////////////////////// inizia client per query

   if (VPmap[qu].lev=='M')   {  

   printf ("VPmap[qu].lev for M is :%d\n",VPmap[qu].lev);
   read_32_arg.q=qu; 
   printf ("Encryption of B[q] on the server is :%d\n",read_32_arg.a[read_32_arg.q]);

        
  /*#ifndef	DEBUG  ///////////////  az inja ezafeh baraye seda kardan
	clnt = clnt_create (host, GO_ORAM, ver, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}*/
 // #endif	/* DEBUG */

	result_1 = read_32(&read_32_arg, clnt);
	if (result_1 == (rx *) NULL) {
		clnt_perror (clnt, "call failed");
	}  ///// ta inja ezafeh baraye seda kardan

   printf ("Download of M-pos[q] from server is :%d\n",result_1->arr[read_32_arg.q]);
   //printf ("Decryption of M-pos[q] is : %d\n",read_32_arg.a[array[read_32_arg.q]]);
   printf ("Decryption of M-pos[q] is : %d\n",B[qu]);
   
   
                   /////////////////////////////////////////////

/*  inja tike kardam bordam payin */

printf ("sto stampando read_32_arg.a[i]\n");//
for (i=0; i < read_32_arg.N+read_32_arg.s; i++)//
printf ("%d\n",read_32_arg.a[i]);//

  Sh[nSh]=read_32_arg.a[read_32_arg.q];   
  VPmap[read_32_arg.q].lev='S';
  VPmap[read_32_arg.q].pos=nSh;
  nSh=nSh+1;

printf ("THe new VPmap[read_32_arg.q].lev is : %d \n",VPmap[read_32_arg.q].lev);
printf ("the new VPmap[read_32_arg.q].pos is : %d \n",VPmap[read_32_arg.q].pos);
printf ("nSh is: %d \n",nSh);

  printf ("Sh[i] is:\n");
  for (i=0;i<read_32_arg.s;i++)
  printf ("%d\n",Sh[i]);
  
printf ("***************************************\n");}
                ////////////////////////////////////////////////////

  else  {                /*if (VPmap[qu].lev='S') */
   read_32_arg.q=qu; //
   Sh[nSh]=read_32_arg.a[read_32_arg.q];//faghat khondan boode
   Sh[VPmap[read_32_arg.q].pos]=result_1->arr[dCnt];    
   VPmap[read_32_arg.q].lev='S';
   VPmap[read_32_arg.q].pos=nSh;
   nSh=nSh+1;

  printf ("The second VPmap is :\n");
  for (i=0;i<read_32_arg.N+read_32_arg.s;i++)
  printf ("%d\n",VPmap[i].pos);
  
/// download M[pi(dCnt)] // ehtiji nist chon ghablan destroy nakardim , baz monde
/*#ifndef	DEBUG  ///////////////  az inja ezafeh baraye seda kardan
	clnt = clnt_create (host, GO_ORAM, ver, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
  #endif	/* DEBUG */

	result_1 = read_32(&read_32_arg, clnt);
	if (result_1 == (rx *) NULL) {
		clnt_perror (clnt, "call failed");
	}  ///// ta inja ezafeh baraye seda kardam

 int *b;//
b=(int *) malloc(sizeof(int));
b[0]=result_1->arr[dCnt];  // M[pi(dCnt)]
printf ("b is :%d\n",b[0]);
free(b);
dCnt=dCnt+1;//

printf ("Sh[i] is:\n");
  for (i=0;i<read_32_arg.s;i++)
  printf ("%d\n",Sh[i]);                         
  }


if (nq==read_32_arg.s)   /*  Shift to the oblivious shuffle phase *********** /  */
printf ("***** start the oblivious shuffle phase. ***** \n"); 

///////////////////////////////


} /// end of do

while (nq<read_32_arg.s);


int j;
int k=0;
int p;
int *arrBtc ;
arrBtc=(int *) malloc (sizeof(int));

/*************************************************/

i=0 ;
   
       //while (i<read_32_arg.N+read_32_arg.s) {
         for (i=0;i<read_32_arg.N+read_32_arg.s;i++){
          j=0 ;
          
               while (result_1->arr[i]!=Sh[j]) {
                   j ++ ;
                   if (j==read_32_arg.s) {
                     arrBtc[k]=result_1->arr[i];  
                     k++ ; }
                     } // end of while 
                     
                    
             }
                

/*printf ("result_1->arr[i] is :\n");            
for (i=0;i<read_32_arg.N+read_32_arg.s;i++)
printf ("%d\n",result_1->arr[i]);*/

printf (" size of arrBtc is: %ld\n",sizeof(arrBtc));

printf ("the K is :%d\n",k);                   //  store N remaining blocks
printf ("The array for shuffle phase is : \n");
  for (i=0;i<k;i++) 
  printf ("%d\n",arrBtc[i]);

  /********/

for (i=0;i<read_32_arg.s;i++){          // store S blocks
arrBtc[k]=Sh[i];
k++ ;
}

printf ("The total array for shuffle phase is : \n");  // total of N+S remaining blocks
  for (i=0;i<k;i++) 
  printf ("%d\n",arrBtc[i]);

printf ("the K is :%d\n",k);

//*************************************** Batcher's sort ********************//

int flag,temp,count=0,even,odd;

do {
    flag=0 ;
    count++ ;
    even=0 ;
    odd=0 ;
  
// for odd sort
  for (i=1;i<k-1;i+=2)
    {
     // swapping
      if (arrBtc[i]>arrBtc[i+1])
        {
           temp=arrBtc[i];
           arrBtc[i]=arrBtc[i+1] ;
           arrBtc[i+1]=temp;
           flag=1;
           odd=1;
       }
     }
 
if(odd==1)
  {
     printf ("%d.Array after odd sort \n",count);
       //??????????????

    for(i=0;i<k;i++)
      {
        printf("%d ",arrBtc[i]);
      }
       printf("\n");
   }

//For Even Sort

for (i=0;i<k-1;i+=2)
  {
    // swapping
    if (arrBtc[i]>arrBtc[i+1])
     { 
       temp=arrBtc[i] ;
       arrBtc[i]=arrBtc[i+1] ;
       arrBtc[i+1]=temp; 
       flag=1 ;
       even=1 ;
     }
  }

if (even==1)  
 {
   printf("%d.Array after Even Sort\n",count); 
   //??????????
    for(i=0;i<k;i++)
     {
       printf("%d ",arrBtc[i]);
     }
   printf("\n");

 }

} while (flag);

printf("\nArray after Final Sorting\n");
//????????????????
 for(i=0;i<k;i++)
  {
     printf("%d ",arrBtc[i]);
   }
 printf("\n");
 

for(i=0;i<read_32_arg.N+read_32_arg.s;i++)
 read_32_arg.a[i]=arrBtc[i];

printf (" the read_32_arg.a[i] store in M is :\n");
for (i=0;i<read_32_arg.N+read_32_arg.s;i++)
printf ("%d\n",read_32_arg.a[i]);


//******************* store new permutation in server ******************//

/*#ifndef	DEBUG  ///////////////  ehtiaji nist chon ghablan destroy nakardim baz monde
	clnt = clnt_create (host, GO_ORAM, ver, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
  #endif	/* DEBUG */

	result_1 = read_32(&read_32_arg, clnt);
	if (result_1 == (rx *) NULL) {
		clnt_perror (clnt, "call failed");
	}  ///// ta inja ezafeh baraye seda kardan 
 

  ///**********************////

printf ("which block do you want to access ?\n");
scanf ("%d",&qu) ;
read_32_arg.q=qu ;
 printf ("Download from server is :%d\n",result_1->arr[read_32_arg.q]);//[qu]
 printf ("Decryption of M-pos[q] is : %d\n",B[qu]);



} /// End of function
/////////////***********///////******////////////*****************//////////////

int
main (int argc, char *argv[])
{
	char *host;

	if (argc < 2) {
		printf ("usage: %s server_host\n", argv[0]);
		exit (1);
	}
	host = argv[1];
	go_oram_32 (host);
exit (0);
}

////////////////////////////////////////////////////////////////////////////////

